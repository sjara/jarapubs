'''
Estimate average reward modulation on shuffled data.

It requires data generated by:
generate_summary_shuffled_reward_modulation.py

It took 4 seconds
'''

import os
import numpy as np
from jaratoolbox import settings
import figparams


FIGNAME = 'reward_modulation_shuffled'
figDataFile = 'rewardmod_shuffled.npz'
figDataDir = os.path.join(settings.FIGURES_DATA_PATH, figparams.STUDY_NAME, FIGNAME)
figDataFullPath = os.path.join(figDataDir,figDataFile)


# -- Load data --
figData = np.load(figDataFullPath)
brainAreaEachCell = figData['brainAreaEachCell']
nIter = figData['nIter']
shuffledResults = figData['shuffledResults']

alphaLevel = 0.05
conds = ['modSigLow_0-0.3s_center-out','modSigHigh_0-0.3s_center-out']

brainAreas = ['rightAC','rightAStr']

dataAllIter = []

for dataOneIter in shuffledResults:
    dataAllIter.append(dataOneIter[conds[0]])  # This is inefficient
    dataAllIter.append(dataOneIter[conds[1]])  # This is inefficient

dataAllIter = np.array(dataAllIter)

fractionSignifEachArea = []
meanFractionSignif = []
stdFractionSignif = []
for inda,brainArea in enumerate(brainAreas):
    inThisBrainArea = np.array(brainAreaEachCell)==brainArea
    dataThisArea = dataAllIter[:,inThisBrainArea]
    fractionSignifEachArea = np.mean(dataThisArea<alphaLevel,axis=1)
    meanFractionSignif.append(np.mean(fractionSignifEachArea))
    stdFractionSignif.append(np.std(fractionSignifEachArea))
    print('Fraction of modulated cells ({}): {:0.1%} +/- {:0.1%}'.format(brainArea,meanFractionSignif[inda],stdFractionSignif[inda]))
print('For {} shuffles.'.format(nIter))

#fractionSignifEachIter = np.mean(np.array(dataAllIter)<alphaLevel,axis=1)
#meanFractionSignif = np.mean(fractionSignifEachIter)
#stdFractionSignif = np.std(fractionSignifEachIter)
#print('Fraction of modulated cells ({} iter): {:0.2%} +/- {:0.2%}'.format(nIter,meanFractionSignif,stdFractionSignif))

